[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"mini textbook describes selected algorithms play main role de novo genome assembly. premise book construct algorithms bottom explain step step main ideas stand behind .try avoid mcuch possible ready--use implementations, , course, available, use wouldn’t serve educational purpose. Naturally, many applications included well.default code written R, certain points python also mentioned.HiFi De Bruijn graph pile reads Drosophila genome sequencing. dot represents k-mer (k=23), edges denote neighboring k-mers. larger red dots mark head heterozygous bubbles. Source: pacb.com.","code":""},{"path":"index.html","id":"prerequisites","chapter":"1 Preface","heading":"1.1 Prerequisites","text":"assumed readerhas basic understanding genetics;basic understanding genetics;experience programming R (familiar pipe syntax, etc.)experience programming R (familiar pipe syntax, etc.)contact higher mathematics, e.g. statistics, graph theory.contact higher mathematics, e.g. statistics, graph theory.Throughout book following libraries used assumed reader loaded.","code":"\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(igraph)"},{"path":"introduction.html","id":"introduction","chapter":"2 Introduction to genome assembly","heading":"2 Introduction to genome assembly","text":"Genome assembly regarded one important challenging problems bioinformatics, least since late 80’s, Human Genome Project announced.Genomes tend almost inconceivably long. Human DNA example approximately thousand times longer Bible, species genome even dozens times longer . Yet algorithmic part problem arises mainly length. definitely case biotechnologicians, decades ago constrained within insufficiently effective sequencing techniques. bioinformaticians perspective though core problem located deeper.good analogy, explaining nature challenge, schredded newspaper. De novo assembly resembles reconstruction original document set unarranged pieces, like figure .one can imagine problem difficult, newspaper twenty fourty pages. just one assembly still wouldn’t easy. length genome, although far irrelevant, us secondary issue. hand, repetitive patterns, biotechnologicians problem , complicate journey substantially. Reader perhaps come similar conclusions succeeding topics uncover.One also underline fact transcriptome assembly genome assembly. Read coverage latter relatively uniform, whereas transcriptome can differentially expressed therefore frequency reads can vary lot. genome assembly non-uniform abundance reads simply indicates existence repetitions. case transcription product much less straightforward. Methods overcome issue exist beyond scope textbook.","code":""},{"path":"basic.html","id":"basic","chapter":"3 Basic string manipulations","heading":"3 Basic string manipulations","text":"dive main topics let’s warm basic exercises. one hand problems might regarded form general familiarization string manipulations. able get sense must, least perspective algorithms discussed later. hand problems, like generating k-mers suffixes, absolutely crucial genome assembly one know tee. , without ado, let’s warm .","code":""},{"path":"basic.html","id":"generating-random-dna-sequence","chapter":"3 Basic string manipulations","heading":"3.1 Generating random DNA sequence","text":"Let’s start writing function , given integer n > 0, returns randomly generated DNA sequence.want returned sequence form single string can use paste() function collapse parameter equal ''.now try stick first form, mainly base R good manipulating strings (point try employ additional libraries like stringr). DNA equal 'ACGTG' won’t get substring 'CG' simply writing DNA[2:3] (one python). hand, DNA vector c('', 'C', 'G', 'T', 'G') DNA[2:3] return c('C', 'G') turn can easily merged 'CG'.","code":"\nrandom_sequence <- function(n){\n  return(sample(c('A','C','G','T'), n, replace = TRUE))\n}\n\nrandom_sequence(10)\n#>  [1] \"T\" \"T\" \"C\" \"G\" \"G\" \"A\" \"T\" \"T\" \"T\" \"T\"\npaste(random_sequence(10), collapse = '')\n#> [1] \"CTACCAAGGG\""},{"path":"basic.html","id":"finding-cdna","chapter":"3 Basic string manipulations","heading":"3.2 Finding cDNA","text":"One must know C (cytosine) complementary G (guanine), (adenine) complementary T (thymine). order create cDNA first construct list (Python dictionary) complementary nucleobases.data structure allows us directly pull complementary bases. Let’s build function utilizes .Please note append complementary nucleobase seemingly non-optimal way, namely sequence = c(sequence, new_nucleobase). One argue done append(), . e. sequence = append(sequence, new_nucleobase), fact append R regarded relatively slow function solution usually recommended.also neater way compute, way avoid, kind loops. One can achieve though functions like apply(), sapply() lapply().clear downside using functions like one loss legibility. Applying can also straightforward intuitive writing conventional loop. Advanced programmers though find functions handy, fast readable standard loop. reason try balance two approaches . don’t want code hermetic, also limit deliberately avoiding legitimate solutions.","code":"\nc_bases <- list('A' = 'T', 'C' = 'G', 'G' = 'C', 'T' = 'A')\n\nc_bases['A'][[1]]\n#> [1] \"T\"\ncomplementary_sequence <- function(sequence){\n  complementary = c()\n  for (base in sequence){\n    complementary = c(complementary, c_bases[base][[1]])\n  }\n  return(complementary)\n}\nseq <- random_sequence(20)\ncat(' DNA =', seq, '\\n')\n#>  DNA = C T T A T T C C A C C G G C G T G T A A\ncseq <- complementary_sequence(seq)\ncat('cDNA =', cseq)\n#> cDNA = G A A T A A G G T G G C C G C A C A T T\ncomplementary_sequence <- function(sequence){\n  sapply(seq, function(base) c_bases[base][[1]])\n}"},{"path":"basic.html","id":"finding-reverse-complementary","chapter":"3 Basic string manipulations","heading":"3.3 Finding reverse complementary","text":"Obtaining reverse complementary similar. difference instead appending complementary nucleobases prepend .","code":"\nreverse_complementary <- function(sequence){\n  reverse = c()\n  for (base in sequence){\n    reverse = c(c_bases[base][[1]], reverse)\n  }\n  return(reverse)\n}\nseq <- random_sequence(20)\ncat(' DNA =', seq, '\\n')\n#>  DNA = C G T G T G C C C C G G A G A T A T T T\nrcseq <- reverse_complementary(seq)\ncat('cDNA =', rcseq)\n#> cDNA = A A A T A T C T C C G G G G C A C A C G"},{"path":"graph.html","id":"graph","chapter":"4 Graph theory","heading":"4 Graph theory","text":"","code":""},{"path":"bruijn.html","id":"bruijn","chapter":"5 De Bruijn graph","heading":"5 De Bruijn graph","text":"","code":""},{"path":"bwt.html","id":"bwt","chapter":"6 Burrows-Wheeler transform","heading":"6 Burrows-Wheeler transform","text":"Burrows-Wheeler transform one effective lossless text compression method available. provides reversible transformation text makes easier compress. course, one may wonder text compression genome assembly. matter fact two issues closely related. precise - text compression closely related pattern matching turn crucial genome assembly. broad sense compression algorithms look patterns try remove repetitions. want take advantage feature, especially repetitive patterns tend abundant genomic sequences.worth mentioning Burrows-Wheeler transform also closely related suffix trees suffix arrays, commonly used within pattern matching. relationship studied later perhaps reader already keep trivia mind.1","code":""},{"path":"bwt.html","id":"introduction-1","chapter":"6 Burrows-Wheeler transform","heading":"6.1 Introduction","text":"Burrows-Wheeler transform method often referred “block sorting,” takes block text permutes . permuting block text mean rearranging order symbols. , precise Burrows-Wheeler transform performes specific type permutation, namely circural shift permutation: characters moved one position left, first character moves last position.","code":""},{"path":"bwt.html","id":"burrows-wheeler-matrix","chapter":"6 Burrows-Wheeler transform","heading":"6.2 Burrows-Wheeler matrix","text":"Consider following sequence:order create Burrows-Wheeler matrix, transform can obtained, given string first add dollar sign $ end sequence.Afterwards perform series circular shift permutations.sort sequences assumption dollar sign precedes lexicographically every symbol.convenience let’s split permutations vectors single characters.Thus created Burrows-Wheeler matrix. Sequence last column called Burrows-Wheeler transform.","code":"sequence <- 'GATTACA'sequence  <- str_c(sequence, '$')sequences <- c(sequence)\nn         <- nchar(sequence)\n\nfor (i in 1:(n-1)){\n  sequence <- str_c(str_sub(sequence, 2, n),\n                    str_sub(sequence, 1, 1))\n  \n  sequences <- c(sequences, sequence)\n}\n\ncat(sequences, sep = '\\n')\n#> GATTACA$\n#> ATTACA$G\n#> TTACA$GA\n#> TACA$GAT\n#> ACA$GATT\n#> CA$GATTA\n#> A$GATTAC\n#> $GATTACAsequences <- sort(sequences) \ncat(sequences, sep = '\\n')\n#> $GATTACA\n#> A$GATTAC\n#> ACA$GATT\n#> ATTACA$G\n#> CA$GATTA\n#> GATTACA$\n#> TACA$GAT\n#> TTACA$GAbw.matrix           <- data.frame(matrix(, n, n))\ncolnames(bw.matrix) <- 1:n\n\nfor (i in 1:n){\n  bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n}\n\nknitr::kable(bw.matrix)transform <- paste(bw.matrix[,n], collapse = '')\n\ncat('The Burrows-Wheeler transform of', \n    sequence, 'is', transform)\n#> The Burrows-Wheeler transform of $GATTACA is ACTGA$TA"},{"path":"bwt.html","id":"inverse-transform","chapter":"6 Burrows-Wheeler transform","heading":"6.3 Inverse transform","text":"said beginning transform reversible. transformed sequence going reconstruct Burrows-Wheeler matrix initial sequence .Firstly let’s sort characters transformed sequence.Note string equivalent first column Burrrows-Wheeler transform.Also keep mind characters last first column adjacent. words, point set 2-mers.reconstruction process strictly relies fact Burrows-Wheeler matrix sorted lexicographically. property allow us retrieve remaining columns.2-mers (k-mers general) sorted lexicographically represent first two columns Burrows-Wheeler matrix. can extract last character 2-mer following way:inserting set characters obtained second column, iterating proccess building substrings, sorting , retrieving last characters can fill whole Burrows-Wheeler matrix.Finally move first column endOne can also verify bw.matrix bw.inverse fact .Additionally can encapsulate Burrows-Wheeler transform form single function.One can verify output equal result obtained earlier.pure curiosity lets check Burrows-Wheeler transform longer sequence.Please note input string identical characters adjacent positions, whereas transformed sequence situation appears quite often. substrings identical characters allow us represent sequence condensed manner expediate pattern matching.","code":"first.sequence <- strsplit(transform, split = '')[[1]] %>% sort\npaste(first.sequence, collapse = '')\n#> [1] \"$AAACGTT\"bw.inverse           <- data.frame(matrix(, n, 2))\ncolnames(bw.inverse) <- c(n, 1)\n\nbw.inverse[, 1] <- strsplit(transform, split = '')[[1]]\nbw.inverse[ ,2] <- first.sequence\n\nknitr::kable(bw.inverse)kmers <- apply(bw.inverse, 1, \n               function(x) paste(x, collapse = ''))\nkmers\n#> [1] \"A$\" \"CA\" \"TA\" \"GA\" \"AC\" \"$G\" \"TT\" \"AT\"kmers <- sort(kmers)\nkmers\n#> [1] \"$G\" \"A$\" \"AC\" \"AT\" \"CA\" \"GA\" \"TA\" \"TT\"sapply(kmers, function(x) str_sub(x, 2, 2), \n       simplify = TRUE, USE.NAMES = FALSE)\n#> [1] \"G\" \"$\" \"C\" \"T\" \"A\" \"A\" \"A\" \"T\"for (i in 2:(n-1)){\n  kmers             <- apply(bw.inverse, 1, \n                             function(x) paste(x, collapse = ''))\n  kmers             <- sort(kmers)\n  bw.inverse[, i+1] <- sapply(kmers, function(x) str_sub(x, i, i), \n                              simplify = TRUE, USE.NAMES = FALSE)\n  colnames(bw.inverse)[i+1] = i\n}\nknitr::kable(bw.inverse)bw.inverse[,n+1] <- bw.inverse[, 1]\nbw.inverse       <- bw.inverse[,2:(n+1)]\ncolnames(bw.inverse)[n] = n\n\nknitr::kable(bw.inverse)knitr::kable(bw.inverse == bw.matrix)BWT <- function(sequence){\n  sequence  <- str_c(sequence, '$')\n  sequences <- c(sequence)\n  n         <- nchar(sequence)\n\n  for (i in 1:(n-1)){\n    sequence <- str_c(str_sub(sequence, 2, n),\n                     str_sub(sequence, 1, 1))\n    sequences <- c(sequences, sequence)\n  }\n  sequences <- sort(sequences) \n  \n  bw.matrix           <- data.frame(matrix(, n, n))\n  colnames(bw.matrix) <- 1:n\n\n  for (i in 1:n){\n    bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n  }\n  return(paste(bw.matrix[,n], collapse = ''))\n}BWT('GATTACA')\n#> [1] \"ACTGA$TA\"BWT('ATGCTCGTGCCATCATATAGCGCGCGCGCGATCTCTACGCGCG')\n#> [1] \"GTTTCCG$TCGGGGGAGGGTTGTCCTCCCCCCATCCAAACCAGA\""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
