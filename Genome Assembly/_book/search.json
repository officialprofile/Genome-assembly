[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"mini textbook describes (perhaps one say “describe”) selected algorithms play vital role de novo genome assembly related areas.premise book construct algorithms bottom along brief explanation gists. Naturally, applications included well.default code written R, python shell can appear point well (likely though).","code":""},{"path":"index.html","id":"prerequisites","chapter":"1 Introduction","heading":"1.1 Prerequisites","text":"assumed reader:basic understanding genetics.basic understanding genetics.experience programming R (familiar pipe syntax, etc.)experience programming R (familiar pipe syntax, etc.)contact higher mathematics, e.g. statistics, graph theory.contact higher mathematics, e.g. statistics, graph theory.Throughout book following libraries used assumed reader loaded.","code":"\nlibrary(stringr)\nlibrary(dplyr)"},{"path":"bwt.html","id":"bwt","chapter":"2 Burrows-Wheeler transform","heading":"2 Burrows-Wheeler transform","text":"Burrows-Wheeler transform one effective lossless text compression method available. provides reversible transformation text makes easier compress. course, one may wonder text compression genome assembly. matter fact two issues closely related. precise - text compression closely related pattern matching turn crucial genome assembly. broad sense compression algorithms look patterns try remove repetitions. want take advantage feature, especially repetitive patterns tend abundant genomic sequences.worth mentioning Burrows-Wheeler transform also closely related suffix trees suffix arrays, commonly used within pattern matching. relationship studied later perhaps reader already keep trivia mind.1","code":""},{"path":"bwt.html","id":"introduction-1","chapter":"2 Burrows-Wheeler transform","heading":"2.1 Introduction","text":"Burrows-Wheeler transform method often referred “block sorting,” takes block text permutes . permuting block text mean rearranging order symbols. , precise Burrows-Wheeler transform performes specific type permutation, namely circural shift permutation: characters moved one position left, first character moves last position.","code":""},{"path":"bwt.html","id":"burrows-wheeler-matrix","chapter":"2 Burrows-Wheeler transform","heading":"2.2 Burrows-Wheeler matrix","text":"Consider following sequence:order create Burrows-Wheeler matrix, transform can obtained, given string first add dollar sign $ end sequence.Afterwards perform series circular shift permutations.sort sequences assumption dollar sign precedes lexicographically every ohter symbol.convenience lets permutations single charactersThus created Burrows-Wheeler matrix. Sequence last column called Burrows-Wheeler transform.","code":"\nsequence <- 'GATTACA'\nsequence  <- str_c(sequence, '$')\nsequences <- c(sequence)\nn         <- nchar(sequence)\n\nfor (i in 1:(n-1)){\n  sequence <- str_c(str_sub(sequence, 2, n),\n                    str_sub(sequence, 1, 1))\n  \n  sequences <- c(sequences, sequence)\n}\n\ncat(sequences, sep = '\\n')\n#> GATTACA$\n#> ATTACA$G\n#> TTACA$GA\n#> TACA$GAT\n#> ACA$GATT\n#> CA$GATTA\n#> A$GATTAC\n#> $GATTACA\nsequences <- sort(sequences) \ncat(sequences, sep = '\\n')\n#> $GATTACA\n#> A$GATTAC\n#> ACA$GATT\n#> ATTACA$G\n#> CA$GATTA\n#> GATTACA$\n#> TACA$GAT\n#> TTACA$GA\nbw.matrix           <- data.frame(matrix(, n, n))\ncolnames(bw.matrix) <- 1:n\n\nfor (i in 1:n){\n  bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n}\n\nknitr::kable(bw.matrix)\ntransform <- paste(bw.matrix[,n], collapse = '')\n\ncat('The Burrows-Wheeler transform of', \n    sequence, 'is', transform)\n#> The Burrows-Wheeler transform of $GATTACA is ACTGA$TA"},{"path":"bwt.html","id":"inverse-transform","chapter":"2 Burrows-Wheeler transform","heading":"2.3 Inverse transform","text":"said beginning transform reversible. transformed sequence going reconstruct Burrows-Wheeler matrix initial sequence .Firstly let’s sort characters transformed sequence.Note string equivalent first column Burrrows-Wheeler transform.Also keep mind characters last first column adjacent. words, point set 2-mers.reconstruction process strictly relies fact Burrows-Wheeler matrix sorted lexicographically. property allow us retrieve remaining columns.2-mers (k-mers general) represent first two columns Burrows-Wheeler matrix. can derive last characters 2-mers following way.inserting set characters obtained second column, iterating proccess building substrings, sorting , retrieving last characters can fill whole Burrows-Wheeler matrix.Finally move first column endOne can also verify bw.matrix bw.inverse fact .Additionally can encapsulate Burrows-Wheeler transform form single function.One can verify output equal result obtained earlier.pure curiosity lets check Burrows-Wheeler transform longer sequence.Please note input string identical characters adjacent positions, whereas transformed sequence situation appears quite often. substrings identical characters allow us represent sequence condensed manner expediate pattern matching.","code":"\nfirst.sequence <- strsplit(transform, split = '')[[1]] %>% sort\npaste(first.sequence, collapse = '')\n#> [1] \"$AAACGTT\"\nbw.inverse           <- data.frame(matrix(, n, 2))\ncolnames(bw.inverse) <- c(n, 1)\n\nbw.inverse[, 1] <- strsplit(transform, split = '')[[1]]\nbw.inverse[ ,2] <- first.sequence\n\nknitr::kable(bw.inverse)\nkmers <- apply(bw.inverse, 1, \n               function(x) paste(x, collapse = ''))\nkmers\n#> [1] \"A$\" \"CA\" \"TA\" \"GA\" \"AC\" \"$G\" \"TT\" \"AT\"\nkmers <- sort(kmers)\nkmers\n#> [1] \"$G\" \"A$\" \"AC\" \"AT\" \"CA\" \"GA\" \"TA\" \"TT\"\nsapply(kmers, function(x) str_sub(x, 2, 2), \n       simplify = TRUE, USE.NAMES = FALSE)\n#> [1] \"G\" \"$\" \"C\" \"T\" \"A\" \"A\" \"A\" \"T\"\nfor (i in 2:(n-1)){\n  kmers             <- apply(bw.inverse, 1, \n                             function(x) paste(x, collapse = ''))\n  kmers             <- sort(kmers)\n  bw.inverse[, i+1] <- sapply(kmers, function(x) str_sub(x, i, i), \n                              simplify = TRUE, USE.NAMES = FALSE)\n  colnames(bw.inverse)[i+1] = i\n}\nknitr::kable(bw.inverse)\nbw.inverse[,n+1] <- bw.inverse[, 1]\nbw.inverse       <- bw.inverse[,2:(n+1)]\ncolnames(bw.inverse)[n] = n\n\nknitr::kable(bw.inverse)\nknitr::kable(bw.inverse == bw.matrix)\nBWT <- function(sequence){\n  sequence  <- str_c(sequence, '$')\n  sequences <- c(sequence)\n  n         <- nchar(sequence)\n\n  for (i in 1:(n-1)){\n    sequence <- str_c(str_sub(sequence, 2, n),\n                     str_sub(sequence, 1, 1))\n    sequences <- c(sequences, sequence)\n  }\n  sequences <- sort(sequences) \n  \n  bw.matrix           <- data.frame(matrix(, n, n))\n  colnames(bw.matrix) <- 1:n\n\n  for (i in 1:n){\n    bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n  }\n  return(paste(bw.matrix[,n], collapse = ''))\n}\nBWT('GATTACA')\n#> [1] \"ACTGA$TA\"\nBWT('ATGCTCGTGCCATCATATAGCGCGCGCGCGATCTCTACGCGCG')\n#> [1] \"GTTTCCG$TCGGGGGAGGGTTGTCCTCCCCCCATCCAAACCAGA\""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
