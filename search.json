[{"path":"index.html","id":"preface","chapter":"1 Preface","heading":"1 Preface","text":"mini textbook describes selected algorithms play fundamental role genome assembly. premise book construct algorithms bottom explain step step main ideas stand behind .try avoid much possible ready--use implementations, course available good quality, use wouldn’t serve educational purpose. Naturally, many applications included well.default code written R, certain points python also mentioned.HiFi De Bruijn graph pile reads Drosophila genome sequencing. dot represents k-mer (k=23), edges denote neighboring k-mers. larger red dots mark head heterozygous bubbles. Source: pacb.com.","code":""},{"path":"index.html","id":"prerequisites","chapter":"1 Preface","heading":"1.1 Prerequisites","text":"assumed reader:basic understanding genetics;basic understanding genetics;experience programming R (familiar loops, data structures, etc.).experience programming R (familiar loops, data structures, etc.).contact higher mathematics, e.g. statistics, graph theory. Expertise field means required though.contact higher mathematics, e.g. statistics, graph theory. Expertise field means required though.Throughout book following libraries used assumed reader loaded.","code":"\nlibrary(stringr)\nlibrary(dplyr)\nlibrary(igraph)"},{"path":"introduction.html","id":"introduction","chapter":"2 Introduction","heading":"2 Introduction","text":"Genome assembly regarded one important challenging problems bioinformatics, perhaps least since late 80’s, Human Genome Project announced. Due exponential growth technology topic still relevant still quite problems face.Genomes tend almost inconceivably long. Human DNA example approximately thousand times longer Bible (letter-wise), species genomes even orders magnitude longer. Yet algorithmic part problem arises mainly length. definitely case biotechnologicians, decades ago constrained within low-thorughput sequencing techniques. bioinformaticians though core problem located bit deeper.Good analogy, explains nature challenge, shredded newspaper (authors call newspaper problem, others use book example). Namely, genome assembly resembles reconstruction original document set unarranged newspaper pieces, like figure .one can imagine problem difficult, newspaper twenty forty pages long. just single sheet task still wouldn’t easy. length genome, although far irrelevant, us secondary issue. hand, repetitive patterns, biotechnologicians problem , complicate journey substantially.One also underline fact transcriptome assembly genome assembly. Read coverage latter relatively uniform, whereas transcriptome can differentially expressed therefore frequency reads varies lot. genome assembly non-uniform abundance reads simply indicates presence repetitive patterns. case transcription product much less straightforward. Methods overcome issue exist beyond scope textbook.","code":""},{"path":"basic.html","id":"basic","chapter":"3 Basic string manipulations","heading":"3 Basic string manipulations","text":"dive main topics let’s warm basic exercises. problems may regarded form general familiarization string manipulations. bioinformatics repertoire sense required. perspective algorithms discussed later problems, like generating k-mers suffixes, absolutely essential one know like back one’s hand.","code":""},{"path":"basic.html","id":"random-dna-sequence","chapter":"3 Basic string manipulations","heading":"3.1 Random DNA sequence","text":"Let’s start writing function , given integer n > 0, returns randomly generated DNA sequence.want returned sequence form single string can use paste() function collapse parameter equal ''.Unfortunately, convenient way retrieve substring. DNA variable equal 'ACGTG' won’t get substring 'CG' simply writing DNA[2:3] (one python). One employing substr() function, .e. substr(DNA, 2, 3). hand, DNA vector c('', 'C', 'G', 'T', 'G') DNA[2:3] return c('C', 'G') turn can merged 'CG' paste(). Either way, one must use certain function order glue letters split sequence.","code":"\nrandom_sequence <- function(n){\n  return(sample(c('A','C','G','T'), n, replace = TRUE))\n}\n\nrandom_sequence(10)\n#>  [1] \"T\" \"A\" \"G\" \"G\" \"T\" \"G\" \"A\" \"C\" \"G\" \"A\"\npaste(random_sequence(10), collapse = '')\n#> [1] \"ACCTGATGGC\""},{"path":"basic.html","id":"find-cdna","chapter":"3 Basic string manipulations","heading":"3.2 Find cDNA","text":"find complementary sequence one must know C (cytosine) complementary G (guanine), (adenine) complementary T (thymine). Also, creating cDNA first construct list (Python dictionary) complementary nucleobases.data structure allows us directly access complementary bases. Let’s build function utilizes .Please note append complementary nucleobase seemingly non-optimal way, namely writing sequence = c(sequence, new_nucleobase). One argue done append(), . e. sequence = append(sequence, new_nucleobase), fact append R regarded relatively slow function solution usually recommended (python using append fine).also neater way compute, way avoid, kind loops. One can achieve though functions like apply(), sapply() lapply().clear downside using functions like one loss legibility. Applying can also straightforward intuitive writing conventional loop. However, advanced programmers find functions handy, fast readable standard loop. reason try balance two approaches . don’t want code hermetic, also limit deliberately avoiding legitimate solutions.","code":"\nc_bases <- list('A' = 'T', 'C' = 'G', 'G' = 'C', 'T' = 'A')\n\nc_bases['A'][[1]]\n#> [1] \"T\"\ncomplementary_sequence <- function(sequence){\n  complementary = c()\n  for (base in sequence){\n    complementary = c(complementary, c_bases[base][[1]])\n  }\n  return(complementary)\n}\nseq <- random_sequence(20)\ncat(' DNA =', seq, '\\n')\n#>  DNA = A T A C C C A T G A T C G C G C G T T A\ncseq <- complementary_sequence(seq)\ncat('cDNA =', cseq)\n#> cDNA = T A T G G G T A C T A G C G C G C A A T\ncomplementary_sequence <- function(sequence){\n  sapply(seq, function(base) c_bases[base][[1]])\n}"},{"path":"basic.html","id":"reverse-complementary","chapter":"3 Basic string manipulations","heading":"3.3 Reverse complementary","text":"Obtaining reverse complementary similar previous excercise. difference instead appending complementary nucleobases prepend .","code":"\nreverse_complementary <- function(sequence){\n  reverse = c()\n  for (base in sequence){\n    reverse = c(c_bases[base][[1]], reverse)\n  }\n  return(reverse)\n}\nseq <- random_sequence(20)\ncat(' DNA =', seq, '\\n')\n#>  DNA = A G G G T G T A G A T A A G A A G G A A\nrcseq <- reverse_complementary(seq)\ncat('cDNA =', rcseq)\n#> cDNA = T T C C T T C T T A T C T A C A C C C T"},{"path":"basic.html","id":"frequency-of-the-nucleobases","chapter":"3 Basic string manipulations","heading":"3.4 Frequency of the nucleobases","text":"","code":"\nfrequency <- function(sequence, percents = FALSE){\n  counts <- table(sequence)\n  divide_counts <- ifelse(percents, sum(counts), 1)\n  return (counts/divide_counts)\n}\nfrequency(seq, percents = TRUE)\n#> sequence\n#>    A    G    T \n#> 0.45 0.40 0.15"},{"path":"basic.html","id":"longest-common-prefix","chapter":"3 Basic string manipulations","heading":"3.5 Longest common prefix","text":"Imputing strings fact consisted vectors characters may particularly convenient. therefore add functionally detects type inputs converts needed.Unfortunately, R differentiates c('','c','t','g') 'ACTG', e.g.account simply add new boolean argument glued function (default equal FALSE). solution far perfect, now good enough.","code":"\nlongest_common_prefix <- function(sequence1, sequence2){\n  min_length = min(length(sequence1), length(sequence2))\n  index = 0\n  if (sequence1[1] != sequence2[1]){\n    return ('No common prefix')\n  }\n  for (i in 2:min_length){\n    if (sequence1[i] != sequence2[i]){\n      return (sequence1[1:i-1])\n    }\n  }\n  return (sequence1[1:min_length])\n}\nlongest_common_prefix(c('A','C','T','G'), c('A', 'C', 'T', 'T', 'T'))\n#> [1] \"A\" \"C\" \"T\"\n\nlongest_common_prefix(c('C','C','T','G'), c('A', 'C', 'T', 'T', 'T'))\n#> [1] \"No common prefix\"\ntypeof(c('A', 'C', 'G', 'T'))\n#> [1] \"character\"\ntypeof('ACGT')\n#> [1] \"character\"\n\nlength(c('A', 'C', 'G', 'T'))\n#> [1] 4\nlength('ACGT')\n#> [1] 1\nlongest_common_prefix <- function(sequence1, sequence2, glued = FALSE){\n  if (glued){\n    sequence1 <- strsplit(sequence1, '')[[1]]\n    sequence2 <- strsplit(sequence2, '')[[1]]\n  }\n  min_length = min(length(sequence1), length(sequence2))\n  index = 0\n  if (sequence1[1] != sequence2[1]){\n    return ('')\n  }\n  for (i in 2:min_length){\n    if (sequence1[i] != sequence2[i]){\n      return (sequence1[1:i-1])\n    }\n  }\n  return (sequence1[1:min_length])\n}\nlongest_common_prefix('ACTG', 'ACCC', glued = TRUE)\n#> [1] \"A\" \"C\"\n\nlongest_common_prefix('TCTG', 'ACCC', glued = TRUE)\n#> [1] \"\""},{"path":"advanced.html","id":"advanced","chapter":"4 More advanced problems","heading":"4 More advanced problems","text":"chapter devoted little specific problems, like managing fasta fastq files. Throughout section operate three different files available NCBI, also included files directory:MK028861.fasta - Zika virusMK028861.fasta - Zika virusNC_001416.fasta - Enterobacteria phage lambdaNC_001416.fasta - Enterobacteria phage lambda","code":""},{"path":"advanced.html","id":"read-fasta-file","chapter":"4 More advanced problems","heading":"4.1 Read fasta file","text":"Fasta file consist two parts - header, describes sequence, sequence . order load first file use basic leadLines() function.one can see point vector 151 elements. entry represents single line loaded file. going remold output convenient form, namely list two elements (header sequence).Let’s talk trough substr(zika[1], 2, nchar(zika[1])) .call(paste0, .list(zika[2:length(zika)])). create header basis initial line fasta file, .e. first element vector. One simply write 'header' = zika[1] also want remove > character beginning. Therefore take substring starting second character ends end (position equal number characters)..call(paste0, .list(zika[2:length(zika)])) needs little explanation. know one can use paste0 function concatenate strings. Unfortunately, imputing vector strings won’t concatenate element togetherThis reason employing .call(). function takes two arguments - name function execute list elements.Fortunately, smoother solve exercise - str_c() function stringr package.","code":"\nzika <- readLines('files/MK028861.fasta')\n\nzika[1:4]\n#> [1] \">MK028861.1 Zika virus isolate Zika virus/H.sapiens-tc/Panama/2015/259359 polyprotein gene, complete cds\"\n#> [2] \"TGACTAAGACTGCGACAGTTCGAGTTTGAAGCGAAAGCTAGCAACAGTATCAACAGGTTTTATTTTGGAT\"                                  \n#> [3] \"TTGGAAACGAGAGTTTCTGGTCATGAAAAACCCAAAAAAGAAATCCGGAGGATTCCGGATTGTCAATATG\"                                  \n#> [4] \"CTAAAACGCGGAGTAGCCCGTGTGAGCCCCTTTGGGGGCTTGAAGAGGCTGCCAGCCGGACTTCTGCTGG\"\n\nlength(zika)\n#> [1] 151\nzika <- list('header' = substr(zika[1], 2, nchar(zika[1])), \n             'sequence' = do.call(paste0, as.list(zika[2:length(zika)])))\npaste0('A', 'B', 'C')\n#> [1] \"ABC\"\n\npaste0(c('A', 'B', 'C'))\n#> [1] \"A\" \"B\" \"C\"\nstringr::str_c(c('A', 'B', 'C'), collapse = '')\n#> [1] \"ABC\"\nzika$header\n#> [1] \"MK028861.1 Zika virus isolate Zika virus/H.sapiens-tc/Panama/2015/259359 polyprotein gene, complete cds\"\n\nsubstr(zika$sequence, 1, 100)\n#> [1] \"TGACTAAGACTGCGACAGTTCGAGTTTGAAGCGAAAGCTAGCAACAGTATCAACAGGTTTTATTTTGGATTTGGAAACGAGAGTTTCTGGTCATGAAAAA\""},{"path":"graph.html","id":"graph","chapter":"5 Graph theory","heading":"5 Graph theory","text":"","code":""},{"path":"bruijn.html","id":"bruijn","chapter":"6 De Bruijn graph","heading":"6 De Bruijn graph","text":"","code":""},{"path":"bwt.html","id":"bwt","chapter":"7 Burrows-Wheeler transform","heading":"7 Burrows-Wheeler transform","text":"Burrows-Wheeler transform one effective lossless text compression method available. provides reversible transformation text makes easier compress. course, one may wonder text compression genome assembly. matter fact two issues closely related. precise - text compression closely related pattern matching turn crucial genome assembly. broad sense compression algorithms look patterns try remove repetitions. want take advantage feature, especially repetitive patterns tend abundant genomic sequences.worth mentioning Burrows-Wheeler transform also closely related suffix trees suffix arrays, commonly used within pattern matching. relationship studied later perhaps reader already keep trivia mind.1","code":""},{"path":"bwt.html","id":"introduction-1","chapter":"7 Burrows-Wheeler transform","heading":"7.1 Introduction","text":"Burrows-Wheeler transform method often referred “block sorting,” takes block text permutes . permuting block text mean rearranging order symbols. , precise Burrows-Wheeler transform performes specific type permutation, namely circural shift permutation: characters moved one position left, first character moves last position.","code":""},{"path":"bwt.html","id":"burrows-wheeler-matrix","chapter":"7 Burrows-Wheeler transform","heading":"7.2 Burrows-Wheeler matrix","text":"Consider following sequence:order create Burrows-Wheeler matrix, transform can obtained, given string first add dollar sign $ end sequence.Afterwards perform series circular shift permutations.sort sequences assumption dollar sign precedes lexicographically every symbol.convenience let’s split permutations vectors single characters.Thus created Burrows-Wheeler matrix. Sequence last column called Burrows-Wheeler transform.","code":"sequence <- 'GATTACA'sequence  <- str_c(sequence, '$')sequences <- c(sequence)\nn         <- nchar(sequence)\n\nfor (i in 1:(n-1)){\n  sequence <- str_c(str_sub(sequence, 2, n),\n                    str_sub(sequence, 1, 1))\n  \n  sequences <- c(sequences, sequence)\n}\n\ncat(sequences, sep = '\\n')\n#> GATTACA$\n#> ATTACA$G\n#> TTACA$GA\n#> TACA$GAT\n#> ACA$GATT\n#> CA$GATTA\n#> A$GATTAC\n#> $GATTACAsequences <- sort(sequences) \ncat(sequences, sep = '\\n')\n#> $GATTACA\n#> A$GATTAC\n#> ACA$GATT\n#> ATTACA$G\n#> CA$GATTA\n#> GATTACA$\n#> TACA$GAT\n#> TTACA$GAbw.matrix           <- data.frame(matrix(, n, n))\ncolnames(bw.matrix) <- 1:n\n\nfor (i in 1:n){\n  bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n}\n\nknitr::kable(bw.matrix)transform <- paste(bw.matrix[,n], collapse = '')\n\ncat('The Burrows-Wheeler transform of', \n    sequence, 'is', transform)\n#> The Burrows-Wheeler transform of $GATTACA is ACTGA$TA"},{"path":"bwt.html","id":"inverse-transform","chapter":"7 Burrows-Wheeler transform","heading":"7.3 Inverse transform","text":"said beginning transform reversible. transformed sequence going reconstruct Burrows-Wheeler matrix initial sequence .Firstly let’s sort characters transformed sequence.Note string equivalent first column Burrrows-Wheeler transform.Also keep mind characters last first column adjacent. words, point set 2-mers.reconstruction process strictly relies fact Burrows-Wheeler matrix sorted lexicographically. property allow us retrieve remaining columns.2-mers (k-mers general) sorted lexicographically represent first two columns Burrows-Wheeler matrix. can extract last character 2-mer following way:inserting set characters obtained second column, iterating proccess building substrings, sorting , retrieving last characters can fill whole Burrows-Wheeler matrix.Finally move first column endOne can also verify bw.matrix bw.inverse fact .Additionally can encapsulate Burrows-Wheeler transform form single function.One can verify output equal result obtained earlier.pure curiosity lets check Burrows-Wheeler transform longer sequence.Please note input string identical characters adjacent positions, whereas transformed sequence situation appears quite often. substrings identical characters allow us represent sequence condensed manner expediate pattern matching.","code":"first.sequence <- strsplit(transform, split = '')[[1]] %>% sort\npaste(first.sequence, collapse = '')\n#> [1] \"$AAACGTT\"bw.inverse           <- data.frame(matrix(, n, 2))\ncolnames(bw.inverse) <- c(n, 1)\n\nbw.inverse[, 1] <- strsplit(transform, split = '')[[1]]\nbw.inverse[ ,2] <- first.sequence\n\nknitr::kable(bw.inverse)kmers <- apply(bw.inverse, 1, \n               function(x) paste(x, collapse = ''))\nkmers\n#> [1] \"A$\" \"CA\" \"TA\" \"GA\" \"AC\" \"$G\" \"TT\" \"AT\"kmers <- sort(kmers)\nkmers\n#> [1] \"$G\" \"A$\" \"AC\" \"AT\" \"CA\" \"GA\" \"TA\" \"TT\"sapply(kmers, function(x) str_sub(x, 2, 2), \n       simplify = TRUE, USE.NAMES = FALSE)\n#> [1] \"G\" \"$\" \"C\" \"T\" \"A\" \"A\" \"A\" \"T\"for (i in 2:(n-1)){\n  kmers             <- apply(bw.inverse, 1, \n                             function(x) paste(x, collapse = ''))\n  kmers             <- sort(kmers)\n  bw.inverse[, i+1] <- sapply(kmers, function(x) str_sub(x, i, i), \n                              simplify = TRUE, USE.NAMES = FALSE)\n  colnames(bw.inverse)[i+1] = i\n}\nknitr::kable(bw.inverse)bw.inverse[,n+1] <- bw.inverse[, 1]\nbw.inverse       <- bw.inverse[,2:(n+1)]\ncolnames(bw.inverse)[n] = n\n\nknitr::kable(bw.inverse)knitr::kable(bw.inverse == bw.matrix)BWT <- function(sequence){\n  sequence  <- str_c(sequence, '$')\n  sequences <- c(sequence)\n  n         <- nchar(sequence)\n\n  for (i in 1:(n-1)){\n    sequence <- str_c(str_sub(sequence, 2, n),\n                     str_sub(sequence, 1, 1))\n    sequences <- c(sequences, sequence)\n  }\n  sequences <- sort(sequences) \n  \n  bw.matrix           <- data.frame(matrix(, n, n))\n  colnames(bw.matrix) <- 1:n\n\n  for (i in 1:n){\n    bw.matrix[i, ] <- strsplit(sequences[i], split = '')[[1]]\n  }\n  return(paste(bw.matrix[,n], collapse = ''))\n}BWT('GATTACA')\n#> [1] \"ACTGA$TA\"BWT('ATGCTCGTGCCATCATATAGCGCGCGCGCGATCTCTACGCGCG')\n#> [1] \"GTTTCCG$TCGGGGGAGGGTTGTCCTCCCCCCATCCAAACCAGA\""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
